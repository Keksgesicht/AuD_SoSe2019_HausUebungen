 \documentclass[ngerman,
 				a4paper,
 				fontsize=12pt]
 				{article}

\usepackage[a4paper, left=22mm, right=22mm, top=22mm, bottom=22mm]{geometry}
\usepackage[hidelinks]{hyperref}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{amsmath}
\usepackage{nccmath}
\usepackage{amssymb}
\usepackage{pbox}

\title{Algorithmen und Datenstrukturen - Hausübung 09}
\date{ }

\renewcommand*\contentsname{Inhaltsverzeichnis}
\setcounter{secnumdepth}{0}

\hyphenation{Wer-ten}

\begin{document}
	
	\maketitle

	\section*{Gruppenmitglieder}
	
		\begin{itemize}
			\item Emre Berber (2957148)
			\item Christoph Berst (2743394)
			\item Jan Braun (2768531)
		\end{itemize}
	
	\vspace{1.5em}
	\thispagestyle{empty}
	\tableofcontents
	\newpage
	\setcounter{page}{1}
	
	\section{H1}
		
		\subsection{a)}
			
			\includegraphics[width=0.10\linewidth]{picture/H1a/Picture1.png}
			\includegraphics[width=0.13\linewidth]{picture/H1a/Picture2.png}
			\vspace{-1cm}
			\\ \\			
			\includegraphics[width=0.23\linewidth]{picture/H1a/Picture3.png}
			\hfill
			\includegraphics[width=0.32\linewidth]{picture/H1a/Picture4.png}
			\hfill
			\includegraphics[width=0.40\linewidth]{picture/H1a/Picture5.png}
			\\ \\
			\includegraphics[width=0.44\linewidth]{picture/H1a/Picture6.png}
			\hfill
			\includegraphics[width=0.50\linewidth]{picture/H1a/Picture7.png}
			\\ \\
			\includegraphics[width=0.45\linewidth]{picture/H1a/Picture8.png}
			\hfill
			\includegraphics[width=0.50\linewidth]{picture/H1a/Picture9.png}
			\\ \\
			\includegraphics[width=0.47\linewidth]{picture/H1a/Picture10.png}
			\hfill
			\includegraphics[width=0.50\linewidth]{picture/H1a/Picture11.png}
			
		\vfill
		\subsection{b)}
		
			\includegraphics[width=0.51\linewidth]{picture/H1b/Picture1.png}
			\hfill
			\includegraphics[width=0.46\linewidth]{picture/H1b/Picture2.png}
		
		\vfill	
		\subsection{c)}
		
			\begin{tabular}{ | c | p{67mm} | p{67mm} |}
				\hline
										& \vspace{-1ex} \textbf{Einfügen}
										& \vspace{-1ex} \textbf{Löschen}
				\\ \hline
				\textbf{Invariante:}	& \parbox{67mm}{
											\vspace{1ex}
											Jeder Knoten hat maximal $2t-1$ Werte.
											\vspace{1ex}
										}
										& \parbox{67mm}{
											\vspace{1ex}
											Jeder Kindknoten auf Pfad des zu löschenden Knotens hat mindestens $t$ Werte.
											\vspace{1ex}
										}
				\\ \hline
				\textbf{Beweis:}		& \parbox{67mm}{
											\vspace{1ex}
											Jedes Mal, wenn der Einfüge-Algorithmus auf einen Knoten mit $2t-1$ Werten stößt, wird dieser aufgesplittet, sodass dieser und seine Kinder definitiv weniger als $2t-1$ Werten besitzen.
											\vspace{1ex}
										}
										& \parbox{67mm}{
											\vspace{1ex}
											Wenn darauffolgender Kindknoten nur \mbox{$t-1$} Werte hat, wird dieser, je nach Zustand der darumliegenden Knoten, verschoben, verschmolzen oder rotiert.
											\vspace{1ex}
										}
				\\ \hline
			\end{tabular}
			
		\newpage
		\subsection{d)}
		
			\textit{"to be filled in"}
		
	\vfill
	\section{H2}
		
		\textit{"to be filled in"}
	
	\vfill
	\section{H3}
	
		\subsection{a)}
			
			\subsubsection{i)}
				
				\begin{minipage}[t]{0.56\linewidth}
					\vspace{0pt}		
					\fbox{\begin{minipage}{\textwidth} % box
							\ttfamily
							\begin{tabbing}
								\hspace*{2em}\= \hspace*{2em}\= \hspace*{2em}\= \hspace*{2em}\= \hspace*{2em}\= \hspace*{2em}\= \kill % set the tabbings
								Labyrinth(L,S,Z) \\
								1	\>	P = S \\
								2	\>	$\varepsilon$ = 1 \\
								3	\>	WHILE d(P,Z) $\neq$ 0 \\
								4	\>	\>	FOR x=0 TO L.length$-$1 \\
								5	\>	\>	\>	New(NL) \\
								6	\>	\>	\>	IF P $\neq$ L[x] $\land$ A $\neq$ L[x] $\land$ d(P,X) $\leq \varepsilon$ \\
								7	\>	\>	\>	\> Add(NL,L[x]) \\
								8	\>	\>	\>	IF NL.length == 0 \\
								9	\>	\>	\>	\>	P = A \\
								10	\>	\>	\>	\>	BREAK \\		
								11	\>	\>	\>	A = P \\
								12	\>	\>	\>	IF NL.length == 1 \\
								13	\>	\>	\>	\>	P = NL[0] \\
								14	\>	\>	\>	ELSE \\
								15	\>	\>	\>	\>	FOR n=0 TO NL.length$-$1 \\
								16	\>	\>	\>	\>	\>	IF d(P,Z) $>$ d(NL[n],Z) \\
								17	\>	\>	\>	\>	\>	\>	P = NL[n] \\
								18	\>	\>	\>	\>	IF A == P \\
								19	\>	\>	\>	\>	\>	P = NL[RandomNextInt(N.length)] \\
								20	\>	\>	setPosition(F,P)
							\end{tabbing}
					\end{minipage}}
				\end{minipage}
				\begin{minipage}[t]{0.44\linewidth}
					\vspace{-2mm}
					\begin{itemize}
						\item NL ist die Liste der Nachbarn des akuellen Position P der Figur F, welche durch Auswertung der x und y Koordinaten der in ihr gespeicherten Punkte, gegen den Uhrzeigersinn sortiert ist.
						\item d(L1,L2) ist die Distanz-Funktion d aus der Aufgabenstellung, wobei L1, L2 $\in L^{2}$
						\item Unser Qualitycheck findet durch Zeile 6 und Zeile 13 statt: Es wird versucht eine Nachbarposition mit einem geringern Abstand zu finden
						\item Es wird versucht nicht auf den letzte Position rückkehren zu können, um somit in Sackgassen nicht stecken zu bleiben, in denen man sonst immer wieder gegen die Wand laufen würde.
						\item RandomNextInt(m) gibt einen Wert \\ r $\in [0,m) \subseteq \mathbb{N}$ zurück.
						\item setPosition(F,P) setzt die Figur F auf den Punkt P.
					\end{itemize}
				\end{minipage}						
			
			\vfill	
			\subsubsection{ii)}
			
				(5,1) $\rightarrow$ (5,2) $\rightarrow$ (4,2) $\rightarrow$ (4,3) $\rightarrow$ (4,4) $\rightarrow$ (3,4) $\rightarrow$ (3,5) $\rightarrow$ (2,5) $\rightarrow$ (1,5)
				
			\vfill
			\subsubsection{iii)}
			
				Während der Bearbeitung der i) haben wir unbemerkt unseren Algorithmus schon verbessert, in dem wir speichern auf welchem Feld er sich vorher befand (Variable A). Damit versuchen wir zu verhindern, dass die Figur andauernd versucht in Sackgassen ständig wieder zur Wand zu laufen. Sobald er an der Wand ist, sucht der Algorithmus nach einen Feld, welches immer noch nah genug ist, aber nicht das Feld ist auf dem er herkam. Somit versucht er vom lokalen Maximum zu dem globalen Maximum über qualitativ schlechtere Felder zu gelangen.
		
		\vfill
		\subsection{b)}
	
			\subsubsection{i)}
			
				\begin{minipage}[t]{0.46\linewidth}
					\vspace{0pt}
					\fbox{\begin{minipage}{\textwidth} % box
							\ttfamily
							\begin{tabbing}
								\hspace*{2em}\= \hspace*{2em}\= \hspace*{2em}\= \kill % set the tabbings
								Bergsteiger(L,f,S) \\
								1	\>	best = S \\
								2	\>	$\varepsilon$ = 1 \\
								3	\>	REPEAT \\
								4	\>	\>	S = best \\
								5	\>	\>	R = getBiggestNeighbor(L,S,f,$\varepsilon$) \\
								6	\>	\>	IF f(R) > f(S) \\
								7	\>	\>	\>	best = R \\
								8	\>	UNTIL S == best \\
								9	\>	RETURN best
							\end{tabbing}
					\end{minipage}}
				\end{minipage}
				\begin{minipage}[t]{0.54\linewidth}
					\vspace{0pt}
					die Funktion getBiggestNeighbor(L,S,f,$\varepsilon$) sucht einen Wert X $\in$ L $\times$ L, dessen wobei d(S,X) $\leq \varepsilon$ ist. All diese Werte gegen den Uhrzeigersinn durchgegangen in mit Hilfe von der Qualiätsfunktion f wird der Größte/Beste unter ihnen bestimmt.
					\\ \\ \\
					Unser Algorithmus versucht ständig zum größtmöglichen Nachbarn zu gelangen bis der aktuelle Punkt keinen größeren Nachbarn mehr hat. Dieser Punkt ist dann ein lokales Maximum in der Funktion f.
				\end{minipage}
			
			\subsubsection{ii)}
			
				\begin{fleqn}[\parindent]
					\begin{equation*}
						\begin{split}
								& S_{0}: && f((-2,-4)) = 0	&& \rightarrow && f((-2,-4)) = 0 \\
								& S_{1}: && f((4,4)) = 0	&& \rightarrow && f((3,3)) = 0.094 && \rightarrow && f((2,2)) = 1.508 && \rightarrow && f((1,2)) = 3.0625 \\
						\end{split}
					\end{equation*}
				\end{fleqn}
			
			
\end{document}
