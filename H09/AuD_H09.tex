 \documentclass[ngerman,
 				a4paper,
 				fontsize=12pt]
 				{article}

\usepackage[a4paper, left=22mm, right=22mm, top=22mm, bottom=22mm]{geometry}
\usepackage[hidelinks]{hyperref}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{amsmath}
\usepackage{nccmath}
\usepackage{amssymb}
\usepackage{pbox}

\title{Algorithmen und Datenstrukturen - Hausübung 09}
\date{ }

\renewcommand*\contentsname{Inhaltsverzeichnis}
\setcounter{secnumdepth}{0}

\hyphenation{Wer-ten}

\begin{document}
	
	\maketitle

	\section*{Gruppenmitglieder}
	
		\begin{itemize}
			\item Emre Berber (2957148)
			\item Christoph Berst (2743394)
			\item Jan Braun (2768531)
		\end{itemize}
	
	\vspace{1.5em}
	\thispagestyle{empty}
	\tableofcontents
	\newpage
	\setcounter{page}{1}
	
	\section{H1}
		
		\subsection{a)}
			
			\includegraphics[width=0.10\linewidth]{picture/H1a/Picture1.png}
			\includegraphics[width=0.13\linewidth]{picture/H1a/Picture2.png}
			\vspace{-1cm}
			\\ \\			
			\includegraphics[width=0.23\linewidth]{picture/H1a/Picture3.png}
			\hfill
			\includegraphics[width=0.32\linewidth]{picture/H1a/Picture4.png}
			\hfill
			\includegraphics[width=0.40\linewidth]{picture/H1a/Picture5.png}
			\\ \\
			\includegraphics[width=0.44\linewidth]{picture/H1a/Picture6.png}
			\hfill
			\includegraphics[width=0.50\linewidth]{picture/H1a/Picture7.png}
			\\ \\
			\includegraphics[width=0.45\linewidth]{picture/H1a/Picture8.png}
			\hfill
			\includegraphics[width=0.50\linewidth]{picture/H1a/Picture9.png}
			\\ \\
			\includegraphics[width=0.47\linewidth]{picture/H1a/Picture10.png}
			\hfill
			\includegraphics[width=0.50\linewidth]{picture/H1a/Picture11.png}
			
		\vfill
		\subsection{b)}
		
			\includegraphics[width=0.70\linewidth]{picture/H1b/Picture1.png}
			\\ \\
			\includegraphics[width=0.63\linewidth]{picture/H1b/Picture2.png}
		
		\vfill	
		\subsection{c)}
		
			\begin{tabular}{ | c | p{67mm} | p{67mm} |}
				\hline
										& \vspace{-1ex} \textbf{Einfügen}
										& \vspace{-1ex} \textbf{Löschen}
				\\ \hline
				\textbf{Invariante:}	& \parbox{67mm}{
											\vspace{1ex}
											Jeder Knoten hat maximal $2t - 1$ Werte.
											\vspace{1ex}
										}
										& \parbox{67mm}{
											\vspace{1ex}
											Jeder Kindknoten auf Pfad des zu löschenden Knotens hat mindestens $t$ Werte.
											\vspace{1ex}
										}
				\\ \hline
				\textbf{Beweis:}		& \parbox{67mm}{
											\vspace{1ex}
											Jedes Mal, wenn der Einfüge-Algorithmus auf einen Knoten mit $2t-1$ Werten stößt, wird dieser aufgesplittet, sodass dieser und seine Kinder definitiv weniger als $2t-1$ Werten besitzen.
											\vspace{1ex}
										}
										& \parbox{67mm}{
											\vspace{1ex}
											zu besuchende Kindknoten mit nur $t - 1$ Werten werden mit direkten Geschwistern, die nur $t - 1$ Werte haben, verschmolzen. Falls ein Geschwister mehr als $t - 1$ Werte besitzt, wird der Wert in Richtung dem zu besuchenden Kind rotiert.
											\vspace{1ex}
										}
				\\ \hline
			\end{tabular}
			
		\newpage
		\subsection{d)}
		
			Beim \textbf{Einfügen} würde splitten nicht mehr ausreichen, da aus $2t - 1$ Werten mindestens ein Knoten mit $t - 1$ Knoten entsteht. Nur der Knoten, bei dem die Suche nach der Position zum Einfügen hätte eine Chance $t$ Werte zu besitzen. Der beim splitten entstandene Elternwert würde dann einem Knoten mit sowieso schon $t$ Werten hinzugefügt werden, womit das splitten häufiger auftreten könnte. Was mit dem Knoten geschieht, bei dem die Suche nicht weitergeht, ist ungewiss. Wenn man ihn mit $t - 1$ lässt, hält er sich unerlaubt in Baum auf. Wenn ihn über den neuentstandenen Elternwert rotiert, wird der Baum unvollständig. 
			\\ \\
			Auf das \textbf{Löschen} hat dies im Prinzip keine Auswirkung siehe c) Invariante Löschen.
		
	\vfill
	\section{H2}
		
		\textit{"to be filled in"}
	
	\vfill
	\section{H3}
	
		\subsection{a)}
			
			\subsubsection{i)}
				
				\begin{minipage}[t]{0.56\linewidth}
					\vspace{0pt}		
					\fbox{\begin{minipage}{\textwidth} % box
							\ttfamily
							\begin{tabbing}
								\hspace*{2em}\= \hspace*{2em}\= \hspace*{2em}\= \hspace*{2em}\= \hspace*{2em}\= \hspace*{2em}\= \kill % set the tabbings
								Labyrinth(L,S,Z) \\
								1	\>	P = S \\
								2	\>	$\varepsilon$ = 1 \\
								3	\>	WHILE d(P,Z) $\neq$ 0 \\
								4	\>	\>	FOR x=0 TO L.length$-$1 \\
								5	\>	\>	\>	New(NL) \\
								6	\>	\>	\>	IF P $\neq$ L[x] $\land$ A $\neq$ L[x] $\land$ d(P,X) $\leq \varepsilon$ \\
								7	\>	\>	\>	\> Add(NL,L[x]) \\
								8	\>	\>	\>	IF NL.length == 0 \\
								9	\>	\>	\>	\>	P = A \\
								10	\>	\>	\>	\>	BREAK \\		
								11	\>	\>	\>	A = P \\
								12	\>	\>	\>	IF NL.length == 1 \\
								13	\>	\>	\>	\>	P = NL[0] \\
								14	\>	\>	\>	ELSE \\
								15	\>	\>	\>	\>	FOR n=0 TO NL.length$-$1 \\
								16	\>	\>	\>	\>	\>	IF d(P,Z) $>$ d(NL[n],Z) \\
								17	\>	\>	\>	\>	\>	\>	P = NL[n] \\
								18	\>	\>	\>	\>	IF A == P \\
								19	\>	\>	\>	\>	\>	P = NL[RandomNextInt(N.length)] \\
								20	\>	\>	setPosition(F,P)
							\end{tabbing}
					\end{minipage}}
				\end{minipage}
				\begin{minipage}[t]{0.44\linewidth}
					\vspace{-2.3mm}
					\begin{itemize}
						\item NL ist die Liste der Nachbarn des akuellen Position P der Figur F, welche durch Auswertung der x und y Koordinaten der in ihr gespeicherten Punkte, gegen den Uhrzeigersinn sortiert ist.
						\item d(L1,L2) ist die Distanz-Funktion d aus der Aufgabenstellung, wobei L1, L2 $\in L^{2}$
						\item Unser Qualitycheck findet durch Zeile 6 und Zeile 13 statt: Es wird versucht eine Nachbarposition mit einem geringern Abstand zu finden
						\item Es wird versucht nicht auf den letzte Position rückkehren zu können, um somit in Sackgassen nicht stecken zu bleiben, in denen man sonst immer wieder gegen die Wand laufen würde.
						\item RandomNextInt(m) gibt einen Wert \\ r $\in [0,m) \subseteq \mathbb{N}$ zurück.
						\item setPosition(F,P) setzt die Figur F auf den Punkt P.
					\end{itemize}
				\end{minipage}						
			
			\vfill	
			\subsubsection{ii)}
			
				(5,1) $\rightarrow$ (5,2) $\rightarrow$ (4,2) $\rightarrow$ (4,3) $\rightarrow$ (4,4) $\rightarrow$ (3,4) $\rightarrow$ (3,5) $\rightarrow$ (2,5) $\rightarrow$ (1,5)
				
			\vfill
			\subsubsection{iii)}
			
				Während der Bearbeitung der i) haben wir unbemerkt unseren Algorithmus schon verbessert, in dem wir speichern auf welchem Feld er sich vorher befand (Variable A). Damit versuchen wir zu verhindern, dass die Figur andauernd versucht in Sackgassen ständig wieder zur Wand zu laufen. Sobald er an der Wand ist, sucht der Algorithmus nach einen Feld, welches immer noch nah genug ist, aber nicht das Feld ist auf dem er herkam. Somit versucht er vom lokalen Maximum zu dem globalen Maximum über qualitativ schlechtere Felder zu gelangen.
		
		\vfill
		\subsection{b)}
	
			\subsubsection{i)}
			
				\begin{minipage}[t]{0.46\linewidth}
					\vspace{0pt}
					\fbox{\begin{minipage}{\textwidth} % box
							\ttfamily
							\begin{tabbing}
								\hspace*{2em}\= \hspace*{2em}\= \hspace*{2em}\= \kill % set the tabbings
								Bergsteiger(L,f,S) \\
								1	\>	best = S \\
								2	\>	$\varepsilon$ = 1 \\
								3	\>	REPEAT \\
								4	\>	\>	S = best \\
								5	\>	\>	R = getBiggestNeighbor(L,S,f,$\varepsilon$) \\
								6	\>	\>	IF f(R) > f(S) \\
								7	\>	\>	\>	best = R \\
								8	\>	UNTIL S == best \\
								9	\>	RETURN best
							\end{tabbing}
					\end{minipage}}
				\end{minipage}
				\begin{minipage}[t]{0.54\linewidth}
					\vspace{0pt}
					Die Funktion getBiggestNeighbor(L,S,f,$\varepsilon$) sucht einen Wert X $\in$ L $\times$ L, dessen wobei d(S,X) $\leq \varepsilon$ ist. All diese Werte gegen den Uhrzeigersinn durchgegangen in mit Hilfe von der Qualiätsfunktion f wird der Größte/Beste unter ihnen bestimmt.
					\\ \\ \\
					Unser Algorithmus versucht ständig zum größtmöglichen Nachbarn zu gelangen bis der aktuelle Punkt keinen größeren Nachbarn mehr hat. Dieser Punkt ist dann ein lokales Maximum in der Funktion f.
				\end{minipage}
			
			\subsubsection{ii)}
			
				\begin{fleqn}[\parindent]
					\begin{equation*}
						\begin{split}
								& S_{0}: && f((-2,-4)) = 0	&& \rightarrow && f((-2,-4)) = 0 \\
								& S_{1}: && f((4,4)) = 0	&& \rightarrow && f((3,3)) = 0.094 && \rightarrow && f((2,2)) = 1.508 && \rightarrow && f((1,2)) = 3.0625 \\
						\end{split}
					\end{equation*}
				\end{fleqn}
			
			
\end{document}
