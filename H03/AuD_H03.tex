 \documentclass[ngerman,
 				a4paper,
 				fontsize=12pt]
 				{article}

\usepackage[a4paper, left=22mm, right=22mm, top=22mm, bottom=22mm]{geometry}
\usepackage[hidelinks]{hyperref}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{nccmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{wrapfig}

\title{Algorithmen und Datenstrukturen - Hausübung 03}
\date{ }

\renewcommand*\contentsname{Inhaltsverzeichnis}
\setcounter{secnumdepth}{0}

\begin{document}
	
	\maketitle

	\section*{Gruppenmitglieder}
	
		\begin{itemize}
			\item Emre Berber (2957148)
			\item Christoph Berst (2743394)
			\item Jan Braun (2768531)
		\end{itemize}
	
	\vspace{1.5em}
	\thispagestyle{empty}
	\tableofcontents
	\newpage
	\setcounter{page}{1}
	
	\section{H1}
		
		\subsection{a)}
		
			\begin{fleqn}[\parindent]
				\begin{equation*}
					\begin{split}
						& \Theta(n) = \frac{(n - 1) \cdot (n + 2)}{2} & \text{ also } && O(n) = n^{2} \\
					\end{split}
				\end{equation*}
			\end{fleqn}
			Je nachdem, ob in Zeile 4 vom Partition-Algorithmus (s. Foliensatz 02 - Seite 220-284) $ < $ oder $ \leq $ steht, durchläuft i das Teilarray gar nicht oder komplett. Auf jeden Fall steht i nach Partition an einer der Enden des Teilarrays, weswegen der nächste Rekursionsaufruf unbalanciert mit (Anzahl der Elemente im aktuellen Teilarray) $ -1 $ Elementen geschieht. Das ganze geschieht $ (n - 1) $ mal, da man den letzten Fall bei dem das Teilarray nur noch aus einem Element besteht nicht betrachten muss. Wenn dieses Ablaufen der Elemente nun graphisch betrachten, haben wir nun ein Dreieck. Daher kommt auch das $ \frac{(n + 2)}{2} $. Die $ (n + 2) $ entstehen durch das aneinander legen der Dreiecke. Zur Erinnerung der letzte Rekursionsaufruf hat 2 Elemente.
		
		\subsection{b)}
			
			\begin{wrapfigure}[1]{R}{0.54\textwidth}
				\vspace{-32pt}
				\label{QuickSortTreePicture}
				\includegraphics[width=\linewidth]{H1b_QuickSortTree.png}
				\caption{H1b - Quicksort - Teilarrayzerlegung}
			\end{wrapfigure}
			
			Teilarrayzerlegung s. Figure 1 \\
			\\
			Die fertige Liste sollte nach der Sortierung \\ folgendermaßen aussehen: \\
			$ [2, 3, 5, 7, 8, 10, 11, 16, 17, 19, 20] $
			
		\subsection{c)}
			
			Best-Case: \\ $ [2, 11, 7, 19, 3, 16, 8, 20, 5, 17, 10] $ \\ 23 Vergleiche \\
			\\
			Worst-Case: \\ $ [2, 3, 5, 7, 8, 10, 11, 16, 17, 19, 20] $ \\ 55 Vergleiche \\
	
	\section{H2}
		
		\subsection{a)}
			
			\begin{minipage}[t]{0.4\linewidth}
				\vspace{0pt} % reference top (floating)
				\fbox{\begin{minipage}{\linewidth} % box
				\begin{tabbing}
					\hspace*{2em}\= \hspace*{2.5em}\= \hspace*{3em}\= \hspace*{3.5em}\= \kill % set the tabbings
					Find-Modal-M(Array, left, right) \\
					1	\> // left = 0 \\
					2	\> // right = Array.length $-$ 1 \\
					3	\> WHILE true \\
					4	\> 	\> m = left + (right $-$ left) / 2 \\
					5 	\> 	\> IF Array[m] $>$ Array[m+1] \\
					6	\>	\> 	\> IF m = left \\
					7	\>	\>\	\> \> return m \\
					8	\>	\> 	\> right = m \\
					9	\>	\> ELSE \\
					10	\>	\>	\> IF m = left \\
					11	\>	\>	\>	\> return m+1 \\
					12	\>	\>	\> left = m+1
				\end{tabbing}
				\end{minipage}}
			\end{minipage}
			\begin{minipage}[t]{0.6\linewidth}
				\vspace{6pt} % reference top (floating)
				Laufzeit bestimmt sich da dadurch, dass es sich durch die Zeilen 4, 8 und 12 das betrachtete Array immer halbiert wird. \\
		 		$ f(n) \in \text{O}( \log n ) $ \\
		 		\\
		 		Sobald das betrachtete Array nur noch aus 2 Elementen besteht, wird das jeweils größere Element zurückgegeben.
		 	\end{minipage}

		\subsection{b)}
		
			\fbox{\begin{minipage}{\textwidth} % box
					\begin{tabbing}
						\hspace*{2em}\= \kill % set the tabbings
						BIGGEST-X() \\
						1	\> RETURN Find-Modal-M(V, 0, V.length $-$ 1)
					\end{tabbing}
			\end{minipage}}
		
		\subsection{c)}
			
			\begin{minipage}[t]{0.52\linewidth}
				\vspace{0pt} % reference top (floating)
				\fbox{\begin{minipage}{\textwidth} % box
					\begin{tabbing}
						\hspace*{2em}\= \kill % set the tabbings
						BIGGEST-Y() \\
						1	\> RETURN Find-Modal-M(W, 0, BIGGEST-X())
					\end{tabbing}
				\end{minipage}}
			\end{minipage}
			\begin{minipage}[t]{0.48\linewidth}
				\vspace{6pt} % reference top (floating)
				Da hier einfach nur 2 mal Algorithmen mit $ \log n $ ausgeführt werden, ist es immer noch in O(n)
			\end{minipage}
			
	
	\section{H3}
		
		\subsection{a)}
	
			qwertz
		
		\subsection{b)}
	
			qwertz
		
		\subsection{c)}
	
			qwertz
			
\end{document}