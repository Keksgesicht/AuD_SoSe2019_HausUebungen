 \documentclass[ngerman,
 				a4paper,
 				fontsize=12pt]
 				{article}

\usepackage[a4paper, left=22mm, right=22mm, top=22mm, bottom=22mm]{geometry}
\usepackage[hidelinks]{hyperref}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{nccmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{wrapfig}

\title{Algorithmen und Datenstrukturen - Hausübung 03}
\date{ }

\renewcommand*\contentsname{Inhaltsverzeichnis}
\setcounter{secnumdepth}{0}

\begin{document}
	
	\maketitle

	\section*{Gruppenmitglieder}
	
		\begin{itemize}
			\item Emre Berber (2957148)
			\item Christoph Berst (2743394)
			\item Jan Braun (2768531)
		\end{itemize}
	
	\vspace{1.5em}
	\thispagestyle{empty}
	\tableofcontents
	\newpage
	\setcounter{page}{1}
	
	\section{H1}
		
		\subsection{a)}
		
			\begin{fleqn}[\parindent]
				\begin{equation*}
					\begin{split}
						& \frac{(n - 1) \cdot (n + 2)}{2} \in \text{O}(n^{2}) \\
					\end{split}
				\end{equation*}
			\end{fleqn}
			Je nachdem, ob in Zeile 4 vom Partition-Algorithmus (s. Foliensatz 02 - Seite 220-284) $ < $ oder $ \leq $ steht, durchläuft i das Teilarray gar nicht oder komplett. Auf jeden Fall steht i nach Partition an einer der Enden des Teilarrays, weswegen der nächste Rekursionsaufruf unbalanciert mit (Anzahl der Elemente im aktuellen Teilarray) $ -1 $ Elementen geschieht. Das ganze geschieht $ (n - 1) $ mal, da man den letzten Fall bei dem das Teilarray nur noch aus einem Element besteht nicht betrachten muss. \\
			Wenn dieses Ablaufen der Elemente nun graphisch betrachten, haben wir nun ein Dreieck. Daher kommt auch die Multiplikation mit $ (n + 2) $ und $ \frac{1}{2} $. Die $ (n + 2) $ entstehen durch das aneinander legen der Dreiecke. Zur Erinnerung der letzte Rekursionsaufruf hat 2 Elemente.
		
		\subsection{b)}
			
			\begin{wrapfigure}[15]{R}{0.54\textwidth}
				\vspace{-35pt}
				\includegraphics[width=\linewidth]{H1b_QuickSortTree.png}
			\end{wrapfigure}
			Teilarrayzerlegung seihe Bild rechts
			
		\subsection{c)}
			
			Best-Case: \\ $ [2, 11, 7, 19, 3, 16, 8, 20, 5, 17, 10] $ \\ 23 Vergleiche \\
			\\
			Worst-Case: \\ $ [2, 3, 5, 7, 8, 10, 11, 16, 17, 19, 20] $ \\ 55 Vergleiche \\
			\\ \\ \\ \\	\\
			\vspace{-7.5em}
	
	\section{H2}
		
		\subsection{a)}
		
			\begin{wrapfigure}[9]{L}{0.335\linewidth}
				\ttfamily
				\vspace{-7em}
				\fbox{\begin{minipage}{\linewidth} % box
				\begin{tabbing}
					\hspace*{2em}\= \hspace*{2em}\= \hspace*{2em}\= \hspace*{2em}\= \kill % set the tabbings
					Find-Modal-M(A, l, r) \\
					1	\> // l = 0 \\
					2	\> // r = A.length $-$ 1 \\
					3	\> WHILE true DO\\
					4	\> 	\> m = l + (r $-$ l) / 2 \\
					5 	\> 	\> IF A[m] $>$ A[m+1] THEN \\
					6	\>	\> 	\> IF m == l \\
					7	\>	\>\	\> \> return m \\
					8	\>	\> 	\> r = m \\
					9	\>	\> ELSE \\
					10	\>	\>	\> IF m == l \\
					11	\>	\>	\>	\> return m+1 \\
					12	\>	\>	\> left = m+1
				\end{tabbing}
				\end{minipage}}
			\end{wrapfigure}
			\vspace{2cm}
			
			Laufzeit bestimmt sich da dadurch, dass es sich durch die Zeilen 4, 8 und 12 das betrachtete Array immer halbiert wird.
		 	O$ ( \log n ) $ \\
		 	\\
		 	\underline{Schleifeninvariante:} Zwischen l und r liegt immer m. \\
			\textbf{Initialisierung:} In jedem Modalenarray gibt es ein m. \\
			\textbf{Fortsetzung:} Da m zwischen dem Auf- und dem Absteienteil liegt, muss m in der linken Hälfte liegen, wenn A[m] $>$ A[m+1] absteigen ist, und in der rechten Hälfte, wenn A[m] $\leq$ A[m+1] aufsteigend ist. \\
			\textbf{Terminierung:} Sobald das betrachtete Array nur noch aus 2 Elementen besteht, wird das jeweils größere Element zurückgegeben.
			
		\subsection{b)}
		
			\begin{wrapfigure}[3]{l}{0.49\linewidth}
				\ttfamily
				\vspace{-3.3ex}
				\fbox{\begin{minipage}{\textwidth} % box
						\begin{tabbing}
							\hspace*{2em}\= \kill % set the tabbings
							BIGGEST-X() \\
							1	\> RETURN Find-Modal-M(V, 0, V.length $-$ 1)
						\end{tabbing}
				\end{minipage}}
			\end{wrapfigure}
			
			Die Laufzeit sollte identisch mit der Aufgabe a sein. \\
			Da das Polygon konvex ist, ist das Array V auch modal. \\
		
		\newpage	
		\subsection{c)}
			
			\begin{wrapfigure}[3]{l}{0.475\linewidth}
				\ttfamily
				\vspace{-3.3ex}
				\fbox{\begin{minipage}{\textwidth} % box
					\begin{tabbing}
						\hspace*{2em}\= \kill % set the tabbings
						BIGGEST-Y() \\
						1	\> RETURN Find-Modal-M(W, 0, BIGGEST-X())
					\end{tabbing}
				\end{minipage}}
			\end{wrapfigure}
			
			Da hier einfach nur 2 mal Algorithmen mit $ \log n $ ausgeführt werden, ist es immer noch in $ \text{O}( \log n )$. \\
			Die Punkten werden im Uhrzeigersinn beginnend mit dem Punkt mit dem kleinsten x-Wert aufgelistet. Die y-Werte in W könnten nun nach dem Hochpunkt m auch einen Tiefpunkt besitzen. Deshalb betrachten wir für den größten y-Wert nur den Halbkreis zwischen 0 und dem Punkt, mit dem größten x-Wert.
	
	\section{H3}
		
		\subsection{a)}
	
			Reflexiv: \\
			\begin{fleqn}[\parindent]
				\begin{equation*}
				\begin{split}
					& \text{Sei } P = (x,y) \\
					& P \trianglelefteq P \Leftrightarrow ( x \leq x ) \land ( y \leq y ) \\
				\end{split}
				\end{equation*}
			\end{fleqn}	
			Antisemmetrie: \\
			\begin{fleqn}[\parindent]
				\begin{equation*}
				\begin{split}
					& P \trianglelefteq Q \land Q \trianglelefteq P \Leftrightarrow \\
					& ( ( x_{1} \leq x_{2} ) \land ( y_{1} \leq y_{2} ) ) 
					\land
					( ( x_{1} \geq x_{2} ) \land ( y_{1} \geq y_{2} ) )
					\Rightarrow 
					( x_{1} = x_{2} ) \land ( y_{1} = y_{2} ) \Rightarrow P = Q \\
				\end{split}
				\end{equation*}
			\end{fleqn}
			Transitivität: \\
			\begin{fleqn}[\parindent]
				\begin{equation*}
				\begin{split}
					& \text{Sei } R \in \mathbb{Z}^{2} \text{ mit } R = ( x_{3}, y_{3} ) \\
					& P \trianglelefteq Q \land Q \trianglelefteq R \Leftrightarrow \\
					& ( ( x_{1} \leq x_{2} ) \land ( y_{1} \leq y_{2} ) ) 
					\land
					( ( x_{2} \leq x_{3} ) \land ( y_{2} \leq y_{3} ) )
					\Rightarrow 
					( x_{1} \leq x_{3} ) \land ( y_{1} \leq y_{3} ) \Rightarrow P \trianglelefteq R \\
				\end{split}
				\end{equation*}
			\end{fleqn}
			$ \Rightarrow $ $ \trianglelefteq $ ist eine Ordnungralation auf $ \mathbb{Z}^{2} $ \\
			\\
			Sei P = (1,2) und Q = (2,1), dann ist weder P $ \trianglelefteq $ Q $ \Leftrightarrow ( 1 \leq 2 ) \land ( 2 \leq 1 ) $ noch Q $ \trianglelefteq $ P $ \Leftrightarrow ( 2 \leq 1 ) \land ( 1 \leq 2 ) $ \\
			Also ist $ \trianglelefteq $ keine totale Ordnung auf $ \mathbb{Z}^{2} $ \\
			\\
		\begin{minipage}[t]{0.5\textwidth}
		\subsection{b)}
		
				\fbox{\begin{minipage}{\textwidth} % box
						\ttfamily
						\begin{tabbing}
							\hspace*{2em}\= \hspace*{2em}\= \kill % set the tabbings
							Fin-All-Max(M) \\
							1	\> IF IsEmpty(M) THEN \\
							2	\>	\> RETURN M \\
							3	\> IF Size(M) == 1 THEN \\
							4	\>	\> RETURN M \\
							5	\> p = 0 \\
							6	\> q = 1 \\
							7	\> RETURN Compare(M, p, q)
						\end{tabbing}
				\end{minipage}}
				
				\vspace{3mm}
							
				\fbox{\begin{minipage}{\textwidth} % box
						\ttfamily
						\begin{tabbing}
							\hspace*{2em}\= \hspace*{2em}\= \kill % set the tabbings
							Compare(M, p, q) \\
							1	\> IF p+1 > M.length THEN \\
							2	\>	\> RETURN M \\
							3	\> IF q+1 > M.length THEN \\
							4	\>	\> RETURN Compare(M, p+1, 0) \\
							5	\> IF a == b THEN \\
							6	\>	\> RETURN Compare(M, p, q+1) \\
							7	\> IF M[p] $ \trianglelefteq $ M[q] THEN \\
							8	\>	\> Remove(M, p) \\
							9	\>	\> RETURN Compare(M, q, q+1) \\
							10	\> ELSE \\
							11	\>	\> RETURN Compare(M, p, q+1)
						\end{tabbing}
				\end{minipage}}
				\\
				\\
				{\fontsize{5}{0} \selectfont  M[p] $ \trianglelefteq $ M[q] := M[p].x $ <= $ M[q].x $ \land $ M[p].y $ <= $ M[q].y \\
				Remove(M, p) := removes an element at position p in M}	
		
		\end{minipage}	
		\begin{minipage}[t]{0.5\textwidth}
		\subsection{c)}
	
			Laufzeit: $ (n-1) \cdot n \in \text{O}(n^{2}) $
			
		\end{minipage}	
			
\end{document}
