 \documentclass[ngerman,
 				a4paper,
 				fontsize=12pt]
 				{article}

\usepackage[a4paper, left=22mm, right=22mm, top=22mm, bottom=22mm]{geometry}
\usepackage[hidelinks]{hyperref}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{nccmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{wrapfig}

\title{Algorithmen und Datenstrukturen - Hausübung 03}
\date{ }

\renewcommand*\contentsname{Inhaltsverzeichnis}
\setcounter{secnumdepth}{0}

\begin{document}
	
	\maketitle

	\section*{Gruppenmitglieder}
	
		\begin{itemize}
			\item Emre Berber (2957148)
			\item Christoph Berst (2743394)
			\item Jan Braun (2768531)
		\end{itemize}
	
	\vspace{1.5em}
	\thispagestyle{empty}
	\tableofcontents
	\newpage
	\setcounter{page}{1}
	
	\section{H1}
		
		\subsection{a)}
		
			\begin{fleqn}[\parindent]
				\begin{equation*}
					\begin{split}
						& \Theta \left( \frac{(n - 1) \cdot (n + 2)}{2} \right) & \text{ Also liegt es in } \text{O}(n^{2}) \\
					\end{split}
				\end{equation*}
			\end{fleqn}
			Je nachdem, ob in Zeile 4 vom Partition-Algorithmus (s. Foliensatz 02 - Seite 220-284) $ < $ oder $ \leq $ steht, durchläuft i das Teilarray gar nicht oder komplett. Auf jeden Fall steht i nach Partition an einer der Enden des Teilarrays, weswegen der nächste Rekursionsaufruf unbalanciert mit (Anzahl der Elemente im aktuellen Teilarray) $ -1 $ Elementen geschieht. Das ganze geschieht $ (n - 1) $ mal, da man den letzten Fall bei dem das Teilarray nur noch aus einem Element besteht nicht betrachten muss. \\
			Wenn dieses Ablaufen der Elemente nun graphisch betrachten, haben wir nun ein Dreieck. Daher kommt auch die Multiplikation mit $ (n + 2) $ und $ \frac{1}{2} $. Die $ (n + 2) $ entstehen durch das aneinander legen der Dreiecke. Zur Erinnerung der letzte Rekursionsaufruf hat 2 Elemente.
		
		\subsection{b)}
			
			\begin{wrapfigure}[15]{r}{0.54\textwidth}
				\vspace{-32pt}
				\label{QuickSortTreePicture}
				\includegraphics[width=\linewidth]{H1b_QuickSortTree.png}
				\caption{H1b - Quicksort - Teilarrayzerlegung}
			\end{wrapfigure}
			
			Teilarrayzerlegung s. Figure 1 \\
			\\
			Die fertige Liste sollte nach der Sortierung \\ folgendermaßen aussehen: \\
			$ [2, 3, 5, 7, 8, 10, 11, 16, 17, 19, 20] $
			
		\subsection{c)}
			
			Best-Case: \\ $ [2, 11, 7, 19, 3, 16, 8, 20, 5, 17, 10] $ \\ 23 Vergleiche \\
			\\
			Worst-Case: \\ $ [2, 3, 5, 7, 8, 10, 11, 16, 17, 19, 20] $ \\ 55 Vergleiche \\
	
	\section{H2}
		
		\subsection{a)}
			
			\begin{wrapfigure}[12]{l}{0.37\linewidth}
				\vspace{-3.3ex}
				\fbox{\begin{minipage}{\linewidth} % box
				\begin{tabbing}
					\hspace*{2em}\= \hspace*{2em}\= \hspace*{2em}\= \hspace*{2em}\= \kill % set the tabbings
					Find-Modal-M(Array, left, right) \\
					1	\> // left = 0 \\
					2	\> // right = Array.length $-$ 1 \\
					3	\> WHILE true \\
					4	\> 	\> m = left + (right $-$ left) / 2 \\
					5 	\> 	\> IF Array[m] $>$ Array[m+1] \\
					6	\>	\> 	\> IF m == left \\
					7	\>	\>\	\> \> return m \\
					8	\>	\> 	\> right = m \\
					9	\>	\> ELSE \\
					10	\>	\>	\> IF m == left \\
					11	\>	\>	\>	\> return m+1 \\
					12	\>	\>	\> left = m+1
				\end{tabbing}
				\end{minipage}}
			\end{wrapfigure}
			
			Laufzeit bestimmt sich da dadurch, dass es sich durch die Zeilen 4, 8 und 12 das betrachtete Array immer halbiert wird. \\
		 	O$ ( \log n ) $ \\
		 	\\
		 	Sobald das betrachtete Array nur noch aus 2 Elementen besteht, wird das jeweils größere Element zurückgegeben. \\
		 	\\
		 	Schleifeninvariante - \textbf{Korrektheitsbeweis!}
			\\
			\\
			\\
			\\
			\\
				
		\subsection{b)}
		
			\fbox{\begin{minipage}{\textwidth} % box
					\begin{tabbing}
						\hspace*{2em}\= \kill % set the tabbings
						BIGGEST-X() \\
						1	\> RETURN Find-Modal-M(V, 0, V.length $-$ 1)
					\end{tabbing}
			\end{minipage}}
			
		\newpage
		\subsection{c)}
			
			\begin{wrapfigure}[3]{l}{0.5\linewidth}
				\vspace{-3.3ex}
				\fbox{\begin{minipage}{\textwidth} % box
					\begin{tabbing}
						\hspace*{2em}\= \kill % set the tabbings
						BIGGEST-Y() \\
						1	\> RETURN Find-Modal-M(W, 0, BIGGEST-X())
					\end{tabbing}
				\end{minipage}}
			\end{wrapfigure}
			
			Da hier einfach nur 2 mal Algorithmen mit $ \log n $ ausgeführt werden, ist es immer noch in $ \text{O}( \log n )$. \\
			Die Punkten werden im Uhrzeigersinn beginnend mit dem Punkt mit dem kleinsten x-Wert aufgelistet. Die y-Werte in W könnten nun nach dem Hochpunkt m auch einen Tiefpunkt besitzen. Deshalb betrachten wir für den größten y-Wert nur den Halbkreis zwischen 0 und dem Punkt, mit dem größten x-Wert.
	
	\section{H3}
		
		\subsection{a)}
	
			qwertz
		
		\subsection{b)}
	
			qwertz
		
		\subsection{c)}
	
			qwertz
			
\end{document}