 \documentclass[ngerman,
 				a4paper,
 				fontsize=12pt]
 				{article}

\usepackage[a4paper, left=22mm, right=22mm, top=22mm, bottom=22mm]{geometry}
\usepackage[hidelinks]{hyperref}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{xcolor}

\title{Algorithmen und Datenstrukturen - Hausübung 07}
\date{ }

\setlength{\parindent}{0pt}
\renewcommand*\contentsname{Inhaltsverzeichnis}
\setcounter{secnumdepth}{0}

\begin{document}
	
	\maketitle

	\section*{Gruppenmitglieder}
	
		\begin{itemize}
			\item Emre Berber (2957148)
			\item Christoph Berst (2743394)
			\item Jan Braun (2768531)
		\end{itemize}
	
	\vspace{1.5em}
	\thispagestyle{empty}
	\tableofcontents
	\newpage
	\setcounter{page}{1}
	
	\section{H1}
		
		\subsection{a)}
			
			\includegraphics[width=0.12\linewidth]{picture/H1a/Picture1.png}
			\hspace{0.02\linewidth}
			\includegraphics[width=0.12\linewidth]{picture/H1a/Picture2.png}
			\hspace{0.05\linewidth}
			\includegraphics[width=0.18\linewidth]{picture/H1a/Picture3.png}
			\hspace{0.02\linewidth}
			\includegraphics[width=0.20\linewidth]{picture/H1a/Picture4.png}
			\hspace{0.05\linewidth}
			\includegraphics[width=0.15\linewidth]{picture/H1a/Picture5.png}
			\\ \\
			\includegraphics[width=0.25\linewidth]{picture/H1a/Picture6.png}
			\hspace{0.05\linewidth}
			\includegraphics[width=0.25\linewidth]{picture/H1a/Picture7.png}
			\hspace{0.05\linewidth}
			\includegraphics[width=0.33\linewidth]{picture/H1a/Picture8.png}
			\\ \\
			\includegraphics[width=0.25\linewidth]{picture/H1a/Picture9.png}
			\hspace{0.05\linewidth}
			\includegraphics[width=0.33\linewidth]{picture/H1a/Picture10.png}
			\hspace{0.05\linewidth}
			\includegraphics[width=0.27\linewidth]{picture/H1a/Picture11.png}
			\\ \\
			{\color{gray} grau:} Elterknoten y
		
		\vfill	
		\subsection{b)}
			\begin{minipage}[t]{0.42\linewidth}
				\includegraphics[width=\linewidth]{picture/H1b/Picture1.png}
				{\color{blue} blau:} gesuchter Knoten
			\end{minipage}
			\hfill
			\begin{minipage}[t]{0.42\linewidth}
				\includegraphics[width=\linewidth]{picture/H1b/Picture2.png}
				{\color{orange} orange:} "größter" Knoten y aus L
			\end{minipage}
	
	\newpage		
	\section{H2}
		
		\subsection{a)}
			
			\begin{figure}[!htb]
				\ttfamily
				\begin{minipage}{0.32\textwidth}
					BuildHeap(H.A)
					\includegraphics[width=\linewidth]{picture/H2a/Picture1.png}
				\end{minipage} \hfill
				\begin{minipage}{0.32\textwidth}
					ExtractMax(H)
					\includegraphics[width=\linewidth]{picture/H2a/Picture2.png}
				\end{minipage} \hfill
				\begin{minipage}{0.32\textwidth}
					Insert(H,37)
					\includegraphics[width=\linewidth]{picture/H2a/Picture3.png}
				\end{minipage}
			\end{figure}
			\begin{figure}[!ht]
				\ttfamily
				\begin{minipage}{0.45\textwidth}
					Insert(H,28) \\
					\includegraphics[width=\linewidth]{picture/H2a/Picture4.png}
				\end{minipage} \hfill
				\begin{minipage}{0.52\textwidth}
					Insert(H,42) \\
					\includegraphics[width=\linewidth]{picture/H2a/Picture5.png}
				\end{minipage}
			\end{figure}
			Nach HeapSort(H.A) ist der Baum leer und ein absteigend sortiertes Array ist entstanden.
		
		\vfill	
		\begin{minipage}[t]{0.5\linewidth}
			\subsection{b)}
			
				\begin{itemize}
					\item BuildHeap(H.A) mit A = \{64, 16, 1, 4, 2\}
					\item ExtractMax(H)
					\item Insert(H,32)
					\item ExtractMax(H)
					\item Insert(H,8) 
				\end{itemize}
		\end{minipage}
		\begin{minipage}[t]{0.5\linewidth}
			\subsection{c)}
			
				\begin{minipage}[t]{0.71\textwidth}
					\fbox{\begin{minipage}{\textwidth} % box
							\ttfamily
							\begin{tabbing}
								\hspace*{2em}\= \hspace*{2em}\= \hspace*{2em}\= \hspace*{2em}\= \hspace*{2em}\= \kill % set the tabbings
								delete(H,i) \\
								1	\>	IF isEmpty(H) THEN \\
								2	\>	\>	ERROR 'underflow' \\
								3	\>	IF i == 0 THEN \\
								4	\>	\>	RETURN extractMax(H) \\
								5	\>	result = H.A[i] \\
								6	\>	IF i == H.size-1 THEN \\
								7	\>	\>	H.size = H.size-1 \\
								8	\>	ELSE \\		
								9	\>	\>	H.A = H.A[H.size-1] \\
								10	\>	\>	H.size = H.size-1 \\
								11	\>	\>	heapify (H,i) \\
								12	\>	RETURN result
							\end{tabbing}
					\end{minipage}}
				\end{minipage}
		\end{minipage}
	
	\section{H3}
		
		\subsection{a)}
			
			\begin{minipage}[t]{0.71\textwidth}
				\vspace{0pt}
				\fbox{\begin{minipage}{\textwidth} % box
						\ttfamily
						\begin{tabbing}
							\hspace*{2em}\= \hspace*{2em}\= \hspace*{2em}\= \hspace*{2em}\= \hspace*{2em}\= \kill % set the tabbings
							minPalindrom(w) \\
							1	\>	count = 0 \\
							2	\>	FOR i=0		 TO w.length $-$ 1 \\
							3	\>	\>	j = w.length $-$ 1 \\
							4 	\>	\>	WHILE true DO \\
							5	\>	\>	\>	WHILE(w[i] $\neq$ w[j]) DO \\
							6	\>	\>	\>	\>	j-- \\
							7	\>	\>	\>	IF i == j THEN \\
							8	\>	\>	\>	\>	BREAK \\
							9	\>	\>	\>	IF checkPalindrom(w, i, j) THEN \\
							10	\>	\>	\>	\>	i = j // next iteration of FOR should be i=j+1 \\
							11	\>	\>	\>	\>	BREAK \\
							13	\>	\>	count++ \\
							14	\>	RETURN count
						\end{tabbing}
				\end{minipage}}
			\end{minipage}
			\begin{minipage}[t]{0.29\textwidth}
				\vspace{0pt}
				\fbox{\begin{minipage}{\textwidth} % box
						\ttfamily
						\begin{tabbing}
							\hspace*{2em}\= \hspace*{2em}\= \kill % set the tabbings
							checkPalindrom(w, i, j) \\
							1	\>	WHILE w[i] == w[j] DO \\
							2	\>	\>	i++ \\
							3	\>	\>	j-- \\
							4	\>	IF i < j THEN \\
							5	\>	\> RETURN false \\
							6	\>	ELSE \\
							7	\>	\> RETURN true
						\end{tabbing}
				\end{minipage}}
			\end{minipage}
			\vspace{1ex} \\
			Mit i iterieren wir von links nach rechts über das Wort w und versuchen dabei jeweils mit Hilfe von j das größtmögliche Palindrom, das mit an i beginnt, zu finden. Wenn wir immer die größtmöglichen Palindrome finden, finden wir gleichzeitig auch die geringste Anzahl an Palindromen, da die Vorherigen den meisten Platz für die Folgenden wegnehmen.
				
		\subsection{b)}
		
			\underline{Korrektheit:} \\
			\textit{Induktionsanfang:} \\
			Betrachten für ein Wort mit \textbf{einem} Zeichen. \\
			i und j sind dann daraufhin 0. Da i und j gleich sind wird die erste WHILE-Schleife übersprungen und die TRUE-Schleife wird aufgrund der selben Aussage beendet. count wird auf 1 hochgezählt und die FOR-Schleife endet mit dem Wort. Ein Wort mit einem Zeichen hat ein Palindrom. \\
			Betrachten wir ein Wort mit \textbf{zwei} Zeichen. \\
			Sehen wir uns erst den Fall an in dem zweimal das selbe Zeichen verwendet wird. Dann wird wieder die WHILE-Schleife überprungen und checkPalindrom wird aufgerufen. Die WHILE-Schleife in checkPalindrom läuft einmal durch und da i nun größer als j wird "true" zurückgegeben. i wird an Ende des Palindroms gesetzt, count wird erhöht und die FOR-Schleife endet mit dem Wort. Wörter mit dem selben Zeichen bestehen aus einem Palidrom. \\
			Seien die beiden Zeichen unterschiedlich so wird die WHILE-Schleife zum ersten Mal nicht übersprungen, j wird verringert und ist nun genauso groß wie i. Damit wird count und FOR-Schleife geht in die nächste Iteration. Nun kann man den zweiten Teil wie ein Wort aus einem Zeichen betrachten. Wörter mit komplett verschiedenen Buchstaben bestehen aus so vielen Palidromen wie sie Zeichen haben. \\
			\\
			Gegenbeispiel: "aabba" Annahme: 2 Paliddrome a|abba ; unser Algo: 3 Palidrome aa|bb|a \\
			\\
			\underline{Komplexität:} \\
			Wenn wir von einem Wort ausgehen das vollständig aus unterschiedlichen Buchstaben besteht. \\
			Die äußere FOR-Schleife läuft n mal. Die WHILE-Schleife läuft in jeder FOR-Schleifeniteration n mal. Damit kommen wir auf $n^{2}$. 
			
			
\end{document}
